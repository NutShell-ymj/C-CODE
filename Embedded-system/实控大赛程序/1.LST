C51 COMPILER V9.57.0.0   1                                                                 12/30/2020 23:09:07 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE 1
OBJECT MODULE PLACED IN 1.OBJ
COMPILER INVOKED BY: D:\Keil-C51\keil\C51\BIN\C51.EXE 1.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          typedef unsigned int u16;         //对数据类型进行声明定义
   4          typedef unsigned char u8;
   5          
   6          sbit A0 = P1^0;
   7          sbit A1 = P1^1;
   8          sbit A2 = P1^2;
   9          sbit beep = P1^5;
  10          sbit select = P1^6;
  11          sbit enter = P1^7;
  12          u16 c1,c2,c3,c4;
  13          u8 x,y;
  14          u8 code number_1[]={0x00,0x00,0x82,0xFF,0x80,0x00,0x00,0x00};
  15          u8 code number_2[]={0x00,0x00,0x79,0x49,0x49,0x4F,0x00,0x00};
  16          u8 code number_3[]={0x00,0x00,0x49,0x49,0x49,0x7F,0x00,0x00};
  17          u8 code level[]={0,500,300,150};//难度选择数组
  18          u8 code ledduan[]={0x03,0x0C,0x30,0xC0};
  19          u8 code ledsmile[]={0x3C,0x42,0x95,0xA1,0xA1,0x95,0x42,0x3C};
  20          void delay(u16 i)
  21          {
  22   1              for(x=0;x<i;x++)
  23   1              {
  24   2                      for(y=0;y<120;y++);
  25   2              }
  26   1      }
  27          
  28          void check0()//开机自检程序，2*2点亮，循环16次
  29          {       u16 c5;
  30   1              for(c1=0;c1<4;c1++)
  31   1              {       
  32   2                      for(c5=0;c5<380;c5++)
  33   2                      {
  34   3                              A0=0;A1=0;A2=0;P0=ledduan[c1];
  35   3                              delay(1);
  36   3                              A0=1;A1=0;A2=0;P0=ledduan[c1];
  37   3                              delay(1);
  38   3                              P0=0;
  39   3                      }
  40   2                      for(c5=0;c5<380;c5++)
  41   2                      {               
  42   3                              A0=0;A1=1;A2=0;P0=ledduan[c1];
  43   3                              delay(1);
  44   3                              A0=1;A1=1;A2=0;P0=ledduan[c1];
  45   3                              delay(1);
  46   3                              P0=0;
  47   3                      }
  48   2                      for(c5=0;c5<380;c5++)
  49   2                      {
  50   3                              A0=0;A1=0;A2=1;P0=ledduan[c1];
  51   3                              delay(1);
  52   3                              A0=1;A1=0;A2=1;P0=ledduan[c1];
  53   3                              delay(1);
  54   3                              P0=0;
  55   3                      }
C51 COMPILER V9.57.0.0   1                                                                 12/30/2020 23:09:07 PAGE 2   

  56   2                      for(c5=0;c5<380;c5++)
  57   2                      {
  58   3                              A0=0;A1=1;A2=1;P0=ledduan[c1];
  59   3                              delay(1);
  60   3                              A0=1;A1=1;A2=1;P0=ledduan[c1];
  61   3                              delay(1);
  62   3                              P0=0;
  63   3                      }
  64   2              }
  65   1      }
  66          void displaysmile()//smile_display with beeping 
  67          {       
  68   1              beep = 0;
  69   1              for(c4=0;c4<500;c4++)
  70   1              {
  71   2                      for(c3=0;c3<8;c3++)
  72   2                      {                               
  73   3                              P0 = ledsmile[c3];
  74   3                              if(P1==0x08)
  75   3                              {
  76   4                                      P1=0;
  77   4                              }P1++;  
  78   3                              delay(1);
  79   3                      }       
  80   2              }
  81   1              P0=0;
  82   1              beep = 1;       
  83   1      }
  84          
  85          void displaynumber(u8 n)
  86          {
  87   1              u8 c3=0;
  88   1              if(n==1)
  89   1              {       
  90   2                      for(c4=0;c4<500;c4++)
  91   2                      {
  92   3                              for(c3=0;c3<8;c3++)
  93   3                              {                               
  94   4                                      P0 = number_1[c3];
  95   4                                      if(P1==0x08)
  96   4                                      {
  97   5                                              P1 = 0;
  98   5                                      }P1++;  
  99   4                                      delay(1);
 100   4                              }       
 101   3                      }
 102   2              }
 103   1              
 104   1              if(n==2)
 105   1              {       
 106   2                      for(c4=0;c4<500;c4++)
 107   2                      {
 108   3                              for(c3=0;c3<8;c3++)
 109   3                              {                               
 110   4                                      P0 = number_2[c3];
 111   4                                      if(P1==0x08)
 112   4                                      {
 113   5                                              P1=0;
 114   5                                      }P1++;  
 115   4                                      delay(1);
 116   4                              }       
 117   3                      }
C51 COMPILER V9.57.0.0   1                                                                 12/30/2020 23:09:07 PAGE 3   

 118   2              }
 119   1              
 120   1              if(n==3)
 121   1              {       
 122   2                      for(c4=0;c4<500;c4++)
 123   2                      {
 124   3                              for(c3=0;c3<8;c3++)
 125   3                              {                               
 126   4                                      P0 = number_3[c3];
 127   4                                      if(P1==0x08)
 128   4                                      {
 129   5                                              P1=0;
 130   5                                      }P1++;  
 131   4                                      delay(1);
 132   4                              }       
 133   3                      }
 134   2              }
 135   1      }
 136          
 137          void model_select()
 138          {       
 139   1              u8 *p = 0;
 140   1              u8 mod = *p;
 141   1              select=1;
 142   1              enter=1;
 143   1              while(enter)
 144   1              {
 145   2                      if(mod>3)
 146   2                      {
 147   3                              mod=0;
 148   3                      }
 149   2                      if(select==0)
 150   2                      { 
 151   3                              while(!select);
 152   3                              mod++;  
 153   3                      }displaynumber(mod);    
 154   2              }
 155   1      }
 156          
 157          void main()
 158          {       
 159   1      //      check0();
 160   1      //      displaysmile();
 161   1              model_select();
 162   1              P0=0;
 163   1      
 164   1      }
 165          
 166          //void KeyDown1()//检测有无按键按下并读取键值
 167          //{
 168          ////    char m;
 169          //    for(;;)
 170          //    {
 171          //      GPIO_KEY=0x0f;
 172          //      delay10ms();delay10ms();
 173          //      if(GPIO_KEY!=0x0f)
 174          //      {
 175          //              delay10ms();
 176          //              if(GPIO_KEY!=0x0f)
 177          //              {
 178          //                      KeyState1=1; 
 179          //                      //测试列
C51 COMPILER V9.57.0.0   1                                                                 12/30/2020 23:09:07 PAGE 4   

 180          ////                    Delay10ms();
 181          //                      switch(GPIO_KEY)
 182          //                      {
 183          //                              case(0X07):     KeyValue1=0;break;//0000 0111
 184          //                              case(0X0b):     KeyValue1=1;break;//0000 1011
 185          //                              case(0X0d): KeyValue1=2;break;//0000 1101
 186          //                              case(0X0e):     KeyValue1=3;break;//0000 1110
 187          ////                            default:        KeyValue=17;    //检测出错回复17意思是把数码管全灭掉。
 188          //                      }
 189          //                      //测试行
 190          //                      GPIO_KEY=0xf0;
 191          //                      delay10ms();
 192          //                      switch(GPIO_KEY)
 193          //                      {
 194          //                              case(0X70):     KeyValue1=KeyValue1;break;
 195          //                              case(0Xb0):     KeyValue1=KeyValue1+4;break;
 196          //                              case(0Xd0): KeyValue1=KeyValue1+8;break;
 197          //                              case(0Xe0):     KeyValue1=KeyValue1+12;break;
 198          ////                            default:        KeyValue1=17;
 199          //                      }
 200          ////                    while((m<50)&&(GPIO_KEY!=0xf0))  //检测按键松手检测
 201          ////                    {
 202          ////                    delay10ms();
 203          ////                            m++;
 204          ////                    }
 205          
 206          //              }
 207          //      }
 208          //      DigDisplayN(KeyValue1);
 209          //      if(KeyState1==1)
 210          //        break;
 211          //    }
 212          //}
 213          
 214          
 215          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    561    ----
   CONSTANT SIZE    =     40    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     10    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
